
# Notes:
# 1.  make sure you have created new images if you updated them.
# 2.  Don't use _ no matter what you think, kube doesn't like it in the names
# 3.  apply creates the objects in kubernetes and runs them 
# 4.  deployments are for scaling, pods are just used to test.  deployments create pods using a template.

# To start the PBS Pro cluster, run the following in bash:
minikube start --memory 4gb
eval $(minikube docker-env)
cd k8s; ./build_images.sh; cd ..
kubectl apply -f k8s/pbspro-cluster-rbac.yml
kubectl apply -f k8s/pbspro-cluster-deployment-server.yml
kubectl apply -f k8s/pbspro-cluster-deployment-node.yml
kubectl apply -f k8s/pbspro-cluster-service.yml
KUBE_IP=$(minikube ip)
MANAGEMENT_PORT=$(kubectl get svc pbspro-cluster -ojsonpath="{.spec.ports[?(@.name==\"pbs-server\")].nodePort}")
echo $KUBE_IP $MANAGEMENT_PORT
kubectl exec -it pbspro-cluster -- /bin/bash


# To start the PBS Pro cluster, run the following in xonsh:
minikube start --memory 4gb
minikube docker-env - > /tmp/minikube_docker-env
source-bash /tmp/minikube_docker-env
cd k8s; ./build_images.sh; cd ..
kubectl apply -f k8s/pbspro-cluster-rbac.yml
kubectl apply -f k8s/pbspro-cluster-deployment-server.yml
kubectl apply -f k8s/pbspro-cluster-deployment-node.yml
kubectl apply -f k8s/pbspro-cluster-service.yml
$KUBE_IP=$(minikube ip).strip()
$MANAGEMENT_PORT=$(kubectl get svc pbspro-cluster -ojsonpath='{.spec.ports[?(@.name=="pbs-server")].nodePort}').strip('\'')
echo $KUBE_IP $MANAGEMENT_PORT
# kubectl exec -it pbspro-cluster -- /bin/bash


# To destroy the cluter, run the following:
minikube stop
minikube delete


# Debugging - run the server as a pod:
kubectl apply -f k8s/pbspro-cluster-pod-server.yml
kubectl exec -it pbspro-pod-server -- /bin/bash


# Debugging - log files
kubectl -n default logs pod/pbspro-pod-server -f

# Debugging - get all pods
kubectl get pods --all-namespaces
kubectl get pods --all-namespaces -w  # watch
