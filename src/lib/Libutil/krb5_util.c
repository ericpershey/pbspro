/*
 * Copyright (C) 1994-2020 Altair Engineering, Inc.
 * For more information, contact Altair at www.altair.com.
 *
 * This file is part of the PBS Professional ("PBS Pro") software.
 *
 * Open Source License Information:
 *
 * PBS Pro is free software. You can redistribute it and/or modify it under the
 * terms of the GNU Affero General Public License as published by the Free
 * Software Foundation, either version 3 of the License, or (at your option) any
 * later version.
 *
 * PBS Pro is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.
 * See the GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Commercial License Information:
 *
 * For a copy of the commercial license terms and conditions,
 * go to: (http://www.pbspro.com/UserArea/agreement.html)
 * or contact the Altair Legal Department.
 *
 * Altair’s dual-license business model allows companies, individuals, and
 * organizations to create proprietary derivative works of PBS Pro and
 * distribute them - whether embedded or bundled with other software -
 * under a commercial license agreement.
 *
 * Use of Altair’s trademarks, including but not limited to "PBS™",
 * "PBS Professional®", and "PBS Pro™" and Altair’s logos is subject to Altair's
 * trademark licensing policies.
 *
 */

/**
 * @file	krb5_utils.c
 *
 * @brief
 *  Routines providing Kerberos specific functions
 */

#include <pbs_config.h>   /* the master config generated by configure */

#if defined(PBS_SECURITY) && (PBS_SECURITY == KRB5)

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <time.h>
#include <krb5.h>

#include <pbs_ifl.h>

#include "pbs_krb5.h"

/**
 * @brief
 * 	create or renew ccache from keytab for the gss client side.
 *
 * @return 	int
 * @retval	0 on success
 * @retval	!= 0 otherwise
 */
int
init_pbs_client_ccache_from_keytab(char *err_buf, int err_buf_size)
{
	krb5_error_code ret = KRB5KRB_ERR_GENERIC;
	krb5_context context = NULL;
	krb5_principal pbs_service = NULL;
	krb5_keytab keytab = NULL;
	krb5_creds *creds = NULL;
	krb5_get_init_creds_opt *opt = NULL;
	krb5_ccache ccache = NULL;
	krb5_creds *mcreds = NULL;
	char *realm;
	char **realms = NULL;
	char hostname[PBS_MAXHOSTNAME + 1];
	int endtime = 0;

	creds = malloc(sizeof(krb5_creds));
	if (creds == NULL) {
		snprintf(err_buf, err_buf_size, "malloc failure");
		goto out;
	}
	memset(creds, 0, sizeof(krb5_creds));

	mcreds = malloc(sizeof(krb5_creds));
	if (mcreds == NULL) {
		snprintf(err_buf, err_buf_size, "malloc failure");
		goto out;
	}
	memset(mcreds, 0, sizeof(krb5_creds));

	setenv("KRB5CCNAME", PBS_KRB5_CLIENT_CCNAME, 1);

	ret = krb5_init_context(&context);
	if (ret) {
		snprintf(err_buf, err_buf_size, "Cannot initialize Kerberos context.");
		goto out;
	}

	ret = krb5_sname_to_principal(context, NULL, PBS_KRB5_SERVICE_NAME, KRB5_NT_SRV_HST, &pbs_service);
	if (ret) {
		snprintf(err_buf, err_buf_size, "Preparing principal failed (%s)", krb5_get_error_message(context, ret));
		goto out;
	}

	ret = krb5_cc_resolve(context, PBS_KRB5_CLIENT_CCNAME, &ccache);
	if (ret) /* for ret = true it is not a real error, we will just create new ccache */
		snprintf(err_buf, err_buf_size, "Couldn't resolve ccache name (%s) New ccache will be created.", krb5_get_error_message(context, ret));

	ret = gethostname(hostname, PBS_MAXHOSTNAME + 1);
	if (ret) {
		snprintf(err_buf, err_buf_size, "Failed to get host name");
		goto out;
	}

	ret = krb5_get_host_realm(context, hostname, &realms);
	if (ret) {
		snprintf(err_buf, err_buf_size, "Failed to get host realms (%s)", krb5_get_error_message(context, ret));
		goto out;
	}

	realm = realms[0];
	ret = krb5_build_principal(context, &mcreds->server, strlen(realm), realm, KRB5_TGS_NAME, realm, NULL);
	if (ret) {
		snprintf(err_buf, err_buf_size, "Couldn't build server principal (%s)", krb5_get_error_message(context, ret));
		goto out;
	}

	ret = krb5_copy_principal(context, pbs_service, &mcreds->client);
	if (ret) {
		snprintf(err_buf, err_buf_size, "Couldn't copy client principal (%s)", krb5_get_error_message(context, ret));
		goto out;
	}

	ret = krb5_cc_retrieve_cred(context, ccache, 0, mcreds, creds);
	if (ret) /* for ret = true it is not a real error, we will just create new ccache */
		snprintf(err_buf, err_buf_size, "Couldn't retrieve credentials from cache (%s) New ccache will be created.", krb5_get_error_message(context, ret));
	else
		endtime = creds->times.endtime;

	/* if we have valid credentials in ccache goto out
	 * if the credentials are about to expire soon (60 * 30 = 30 minutes)
	 * then try to renew from keytab.
	 */
	if (endtime - (60 * 30) >= time(NULL)) {
		ret = 0;
		goto out;
	}

	ret = krb5_cc_new_unique(context, "FILE", NULL, &ccache);
	if (ret) {
		snprintf(err_buf, err_buf_size, "Failed to create ccache (%s)", krb5_get_error_message(context, ret));
		goto out;
	}

	ret = krb5_cc_resolve(context, PBS_KRB5_CLIENT_CCNAME, &ccache);
	if (ret) {
		snprintf(err_buf, err_buf_size, "Couldn't resolve cache name (%s)", krb5_get_error_message(context, ret));
		goto out;
	}

	ret = krb5_kt_default(context, &keytab);
	if (ret) {
		snprintf(err_buf, err_buf_size, "Couldn't open keytab (%s)", krb5_get_error_message(context, ret));
		goto out;
	}
	ret = krb5_get_init_creds_opt_alloc(context, &opt);
	if (ret) {
		snprintf(err_buf, err_buf_size, "Couldn't allocate a new initial credential options structure (%s)", krb5_get_error_message(context, ret));
		goto out;
	}

	krb5_get_init_creds_opt_set_forwardable(opt, 1);

	ret = krb5_get_init_creds_keytab(context, creds, pbs_service, keytab, 0, NULL, opt);
	if (ret) {
		snprintf(err_buf, err_buf_size, "Couldn't get initial credentials using a key table (%s)", krb5_get_error_message(context, ret));
		goto out;
	}

	ret = krb5_cc_initialize(context, ccache, creds->client);
	if (ret) {
		snprintf(err_buf, err_buf_size, "Credentials cache initializing failed (%s)", krb5_get_error_message(context, ret));
		goto out;
	}

	ret = krb5_cc_store_cred(context, ccache, creds);
	if (ret) {
		snprintf(err_buf, err_buf_size, "Couldn't store ccache (%s)", krb5_get_error_message(context, ret));
		goto out;
	}

out:
	if (creds)
		krb5_free_creds(context, creds);
	if (mcreds)
		krb5_free_creds(context, mcreds);
	if (opt)
		krb5_get_init_creds_opt_free(context, opt);
	if (pbs_service)
		krb5_free_principal(context, pbs_service);
	if (ccache)
		krb5_cc_close(context, ccache);
	if (realms)
		krb5_free_host_realm(context, realms);
	if (keytab)
		krb5_kt_close(context, keytab);
	if (context)
		krb5_free_context(context);
	return (ret);
}

/**
 * @brief
 * 	clear KRB5CCNAME
 *
 */
void
clear_pbs_ccache_env()
{
	unsetenv("KRB5CCNAME");
}
#endif
