/*
 * Copyright (C) 1994-2020 Altair Engineering, Inc.
 * For more information, contact Altair at www.altair.com.
 *
 * This file is part of the PBS Professional ("PBS Pro") software.
 *
 * Open Source License Information:
 *
 * PBS Pro is free software. You can redistribute it and/or modify it under the
 * terms of the GNU Affero General Public License as published by the Free
 * Software Foundation, either version 3 of the License, or (at your option) any
 * later version.
 *
 * PBS Pro is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.
 * See the GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Commercial License Information:
 *
 * For a copy of the commercial license terms and conditions,
 * go to: (http://www.pbspro.com/UserArea/agreement.html)
 * or contact the Altair Legal Department.
 *
 * Altair’s dual-license business model allows companies, individuals, and
 * organizations to create proprietary derivative works of PBS Pro and
 * distribute them - whether embedded or bundled with other software -
 * under a commercial license agreement.
 *
 * Use of Altair’s trademarks, including but not limited to "PBS™",
 * "PBS Professional®", and "PBS Pro™" and Altair’s logos is subject to Altair's
 * trademark licensing policies.
 *
 */

#include <pbs_config.h>   /* the master config generated by configure */

#if defined(PBS_SECURITY) && (PBS_SECURITY == KRB5)

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <netinet/in.h>

#include "pbs_ifl.h"
#include "net_connect.h"
#include "attribute.h"
#include "dis.h"
#include "dis_init.h"
#include "pbs_gss.h"
#include "batch_request.h"

int (*transport_getc)(int stream);
int (*transport_puts)(int stream, const char *string, size_t count);
int (*transport_gets)(int stream, char *string, size_t count);
int (*transport_rskip)(int stream, size_t nskips);
int (*transport_rcommit)(int stream, int commit);
int (*transport_wcommit)(int stream, int commit);
int (*transport_read)(int fd);

struct gssdis_chan *(*gss_get_chan)(int stream);

extern int (*dis_getc)(int stream);
extern int (*dis_puts)(int stream, const char *string, size_t count);
extern int (*dis_gets)(int stream, char *string, size_t count);
extern int (*disr_skip)(int stream, size_t nskips);
extern int (*disw_commit)(int stream, int commit);
extern int (*disr_commit)(int stream, int commit);

enum TCP_GSS_MSG_TYPES {
        TCP_GSS_CTX = 1, /* starts from 1, zero means EOF */
        TCP_GSS_WRAP,
        TCP_GSS_LAST_MSG
};

/**
 * @brief
 *	Display messages on stderr
 *
 * @param[in] func_name - function name that invokes the error
 * @param[in] msg - error message
 */
void
tcp_gss_display(const char *func_name, const char* msg)
{
	fprintf(stderr, "%s : %s\n", func_name, msg);
}

/**
 * @brief
 *	Display GSS-API messages associated with maj_stat or min_stat to the
 *	stderr
 *
 * @param[in] m - error message followed by GSS maj or min message
 * @param[in] code - gss error code
 * @param[in] type - type of gss error code
 */
static void
display_status_1(const char *m, OM_uint32 code, int type)
{
	OM_uint32 min_stat;
	gss_buffer_desc msg;
	OM_uint32 msg_ctx;
	msg_ctx = 0;

	do {
		gss_display_status(&min_stat, code, type, GSS_C_NULL_OID, &msg_ctx, &msg);
		fprintf(stderr, "%s : %.*s\n", m, (int)msg.length, (char *)msg.value);
		(void) gss_release_buffer(&min_stat, &msg);
	} while (msg_ctx != 0);
  }

/**
 * @brief
 *	The GSS-API messages associated with maj_stat and min_stat are
 *	displayed on stderr, each preceeded by "GSS-API error <msg>: " and
 *	followed by a newline.
 *
 * @param[in] msg - a error string to be displayed with the message
 * @param[in] maj_stat - the GSS-API major status code
 * @param[in] min_stat - the GSS-API minor status code
 */
void
tcp_gss_display_status(const char *msg, OM_uint32 maj_stat, OM_uint32 min_stat)
{
	display_status_1(msg, maj_stat, GSS_C_GSS_CODE);
	display_status_1(msg, min_stat, GSS_C_MECH_CODE);
}

/**
 * @brief
 * 	-dis_gss_pack_buff - pack existing data into front of buffer
 *
 *	Moves "uncommited" data to front of buffer and adjusts pointers.
 *	Does a character by character move since data may over lap.
 * 
 * @param[in] tp - data buffer
 *
 * @return	void
 *
 */
static void
dis_gss_pack_buff(struct gss_disbuf *tp)
{
	size_t amt;
	size_t start;
	size_t i;

	start = tp->tdis_trail;
	if (start != 0) {
		amt = tp->tdis_eod - start;
		for (i = 0; i < amt; ++i) {
			*(tp->tdis_thebuf + i) = *(tp->tdis_thebuf + i + start);
		}
		tp->tdis_lead -= start;
		tp->tdis_trail -= start;
		tp->tdis_eod -= start;
	}
}

/**
 * @brief
 * 	-dis_gss_buff_resize - pack existing data into front of buffer
 *
 *	Moves "uncommited" data to front of buffer and adjusts pointers.
 *	Does a character by character move since data may over lap.
 * 
 * @param[in] tp - tcp data buffer
 *
 * @return	int
 * @retval	0 on success
 * @retval	-1 on error
 *
 */
static int
dis_gss_buff_resize(struct gss_disbuf *tp, size_t newsize)
{
	if (tp->tdis_bufsize >= newsize)
		return 0;

	char *newbuf = realloc(tp->tdis_thebuf, newsize);

	if (newbuf != NULL) {
		tp->tdis_bufsize = newsize;
		tp->tdis_thebuf = newbuf;
		return 0;
	} else {
		return -1;
	}
}

/**
 * @brief
 * 	-dis_gss_clear - reset dis buffer to empty
 *
 * @param[in] tp - data buffer
 *
 * @return	void
 *
 */
void
dis_gss_clear(struct gss_disbuf *tp)
{
	tp->tdis_lead = 0;
	tp->tdis_trail = 0;
	tp->tdis_eod = 0;
}

/**
 * @brief
 * 	-dis_gss_fillbuffer - fill in buffer from data
 *
 * @param[out] to - buffer to be filled in
 * @param[in] data - data
 * @param[in] len - length of data
 *
 * @return	int
 * @retval	length of data on success
 * @retval	-1 on error
 */
static int
dis_gss_fillbuffer(struct gss_disbuf *to, char *data, int len)
{
	size_t remaining_data = len;

	if (remaining_data == 0)
		return 0;

	dis_gss_pack_buff(to);

	ssize_t remaining_cap = to->tdis_bufsize - to->tdis_eod;
	if ((size_t)remaining_cap < remaining_data) {
		if (dis_gss_buff_resize(to, remaining_data - remaining_cap + to->tdis_bufsize))
			return -1;

		remaining_cap = remaining_data;
	}

	memcpy(&to->tdis_thebuf[to->tdis_eod], data, remaining_data);
	to->tdis_eod += remaining_data;

	return remaining_data;
}

/**
 * @brief
 * 	-dis_gss_fill_readbuf - move data from cleartext buffer into readbuffer
 *
 * @param[in] chan
 *
 * @return	void
 */
static void
dis_gss_fill_readbuf(struct gssdis_chan *chan)
{
	struct gss_disbuf *tp;
	struct gss_disbuf *cl;

	tp = &(chan->readbuf);
	cl = &(chan->cleartext);

	if (cl->tdis_eod)
		dis_gss_fillbuffer(tp, cl->tdis_thebuf, cl->tdis_eod);

	dis_gss_clear(&(chan->cleartext));
}

/**
 * @brief
 * 	-dis_gss_read_buff - reads data of length ct from bottom layer into tp buffer
 *	if needed then buffer is resized
 *
 * @param[in] fd - socket descriptor
 * @param[out] to - buffer to be filled in
 * @param[in] ct - length of read data
 *
 * @return	int
 * @retval	>0 	number of characters read
 * @retval	-1 	if error
 * @retval	-2 	if EOF (stream closed)
 */
static int
dis_gss_read_buff(int fd, struct gss_disbuf *tp, uint32_t ct)
{
	int i;
	char *tmcp;
	int len;

	/* compact (move to the front) the uncommitted data */
	dis_gss_pack_buff(tp);

	len = tp->tdis_bufsize - tp->tdis_eod;

	if (len < ct) {
		size_t ru = (ct + tp->tdis_lead + tp->tdis_eod) / DIS_GSS_BUF_SIZE;
		tp->tdis_bufsize = (ru + 1) * DIS_GSS_BUF_SIZE;
		tmcp = (char *) realloc(tp->tdis_thebuf, sizeof(char) * tp->tdis_bufsize);
		if (tmcp == NULL) {
			/* realloc failed */
			return -1;
		}
		tp->tdis_thebuf = tmcp;
		len = tp->tdis_bufsize - tp->tdis_eod;
	}

	i = transport_gets(fd, &tp->tdis_thebuf[tp->tdis_eod], ct);
	if (i > 0)
		tp->tdis_eod += i;

	transport_rcommit(fd, 1);

	return ((i == 0) ? -2 : i);
}

/**
 * @brief
 * 	-dis_gss_read - reads data from bottom layer
 *	if data are wrapped then read the token and unwrap data
 *	if data are cleartext, reads as much as possible
 *	data are filled into readbuf
 *
 * @param[in] fd - socket descriptor
 *
 * @return	int
 * @retval	>0 	number of characters read
 * @retval	-1 	if error
 * @retval	-2 	if EOF (stream closed)
 */
static int
dis_gss_read(int fd)
{
	struct gss_disbuf *tp;
	struct gss_disbuf *enc;
	struct gssdis_chan *chan;
	char *data_out = NULL;
	int len_out;
	int rc;
	enum TCP_GSS_MSG_TYPES type;
	char *data;
	int i;
	unsigned int ct;

	chan = (struct gssdis_chan *) gss_get_chan(fd);
	if (chan == NULL)
		return -1;

	tp = &(chan->readbuf);
	if (!tp)
		return -1;

	/* if no gss -> read cleartext */
	if (chan->gss_extra == NULL || chan->gss_extra->ready == 0) {
		i = transport_read(fd);
		if (i > 0) {
			ct = i;
			return dis_gss_read_buff(fd, tp, ct);
		}

		return ((i == -2) ? -2 : -1);
	}

	i = transport_getc(fd);
	if (i <= 0)
		return ((i == 0) ? -2 : i);
	type = (enum TCP_GSS_MSG_TYPES)i;
	if (type >= TCP_GSS_LAST_MSG)
                return -1;

	data = malloc(sizeof(int));
	if (data == NULL)
		return -1;
	i = transport_gets(fd, data, sizeof(int));
	if (i <= 0)
		return ((i == 0) ? -2 : i);
	if (i < sizeof(int))
		return -1;

	ct = ntohl(*((int *) data));

	free(data);

	if (type > TCP_GSS_LAST_MSG)
		return -1;

	if (type == TCP_GSS_CTX)
		return -1;

	if ((type == TCP_GSS_WRAP) && (chan->gss_extra->gssctx == GSS_C_NO_CONTEXT))
		return -1;

	// we do not have decoded data, we need to read new data into coded buffer
	enc = &chan->gss_readbuf;

	if (dis_gss_buff_resize(enc, ct))
		return -1;

	/* read encoded data into enc buffer - we need all data */
	if (dis_gss_read_buff(fd, enc, ct) != ct)
		return -1;

	rc = pbs_gss_unwrap(chan->gss_extra, &enc->tdis_thebuf[enc->tdis_lead], ct, &data_out, &len_out);

	/* clear enc buffer for next use */
	dis_gss_clear(enc);

	if (rc) {
		free(data_out);
		return -1;
	}

	ct = len_out;
	if (ct == 0)
		return -2;

	if (dis_gss_fillbuffer(tp, data_out, len_out) == ct) {
		free(data_out);
		return ct;
	}

	free(data_out);

	return ((ct == 0) ? -2 : ct);
}

/**
 * @brief
 * 	-dis_gss_rskip - routine to skip over data in read buffer
 *
 * @param[in] fd - file descriptor
 * @param[in] ct - count
 *
 * @return	int
 * @retval	number of characters skipped
 *
 */
static int
dis_gss_rskip(int fd, size_t ct)
{
	struct gss_disbuf *tp;
	struct gssdis_chan *chan;

	chan = (struct gssdis_chan *) gss_get_chan(fd);
	if (chan == NULL)
		return -1;

	tp = &(chan->readbuf);
	if (tp->tdis_lead - tp->tdis_eod < ct)
		ct = tp->tdis_lead - tp->tdis_eod;
	tp->tdis_lead += ct;
	return (int) ct;
}

/**
 * @brief
 * 	-dis_gss_getc - routine to get next character from read buffer
 *
 * @param[in] fd - file descriptor
 *
 * @return	int
 * @retval	>0 	character
 * @retval	-1 	if EOD or error
 * @retval	-2 	if EOF (stream closed)
 *
 */
static int
dis_gss_getc(int fd)
{
	int x;
	struct gss_disbuf *tp;
	struct gssdis_chan *chan;

	chan = (struct gssdis_chan *) gss_get_chan(fd);
	if (chan == NULL)
		return -1;

	/* if cleartex is pre-read -> fill read buffer */
	dis_gss_fill_readbuf(chan);

	tp = &(chan->readbuf);
	if (tp->tdis_lead >= tp->tdis_eod) {
		/* not enought data, try to get more */
		x = dis_gss_read(fd);
		if (x <= 0)
			return ((x == -2) ? -2 : -1); /* Error or EOF */
	}
	return ((int) tp->tdis_thebuf[tp->tdis_lead++]);
}

/**
 * @brief
 * 	-dis_gss_gets - routine to get a string from read buffer
 *
 * @param[in] fd - file descriptor
 * @param[out] str - string to be written
 * @param[in] ct - count
 *
 * @return	int
 * @retval	>0 	number of characters read
 * @retval	0 	if EOD (no data currently avalable)
 * @retval	-1 	if error
 * @retval	-2 	if EOF (stream closed)
 */
static int
dis_gss_gets(int fd, char *str, size_t ct)
{
	int x;
	struct gss_disbuf *tp;
	struct gssdis_chan *chan;

	chan = (struct gssdis_chan *) gss_get_chan(fd);
	if (chan == NULL)
		return -1;

	/* if cleartex is pre-read -> fill read buffer */
	dis_gss_fill_readbuf(chan);

	tp = &(chan->readbuf);
	while (tp->tdis_eod - tp->tdis_lead < ct) {
		/* not enought data, try to get more */
		x = dis_gss_read(fd);
		if (x <= 0)
			return x; /* Error or EOF */
	}
	(void) memcpy(str, &tp->tdis_thebuf[tp->tdis_lead], ct);
	tp->tdis_lead += ct;
	return (int) ct;
}

/**
 * @brief
 * 	dis_gss_puts - routine to put a counted string of characters
 *	into the write buffer.
 *
 * @param[in] fd - file descriptor
 * @param[in] str - string to be written
 * @param[in] ct - count
 *
 * @return	int
 * @retval	>= 0	the number of characters placed
 * @retval	-1 	if error
 */
static int
dis_gss_puts(int fd, const char *str, size_t ct)
{
	struct gss_disbuf *tp;
	char *tmcp;
	struct gssdis_chan *chan;

	chan = (struct gssdis_chan *) gss_get_chan(fd);
	if (chan == NULL)
		return -1;

	tp = &(chan->writebuf);

	if ((tp->tdis_bufsize - tp->tdis_lead) < ct) { /* add room */
		/* no need to lock mutex here, per fd resize */
		size_t ru = (ct + tp->tdis_lead) / DIS_GSS_BUF_SIZE;
		tp->tdis_bufsize = (ru + 1) * DIS_GSS_BUF_SIZE;
		tmcp = (char *) realloc(tp->tdis_thebuf, sizeof(char) * tp->tdis_bufsize);
		if (tmcp != NULL)
			tp->tdis_thebuf = tmcp;
		else
			return -1; /* realloc failed */
	}
	(void) memcpy(&tp->tdis_thebuf[tp->tdis_lead], str, ct);
	tp->tdis_lead += ct;
	return ct;
}

/**
 * @brief
 * 	-dis_gss_rcommit - routine to commit/uncommit read data
 *
 * @param[in] fd - file descriptor
 * @param[in] commit_flag - indication for commit or uncommit
 *
 * @return      int     
 * @retval      0       success
 *
 */
static int
dis_gss_rcommit(int fd, int commit_flag)
{
	struct gss_disbuf *tp;
	struct gssdis_chan *chan;

	chan = (struct gssdis_chan *) gss_get_chan(fd);
	if (chan == NULL)
		return -1;

	tp = &(chan->readbuf);
	if (commit_flag) {
		/* commit by moving trailing up */
		tp->tdis_trail = tp->tdis_lead;
	} else {
		/* uncommit by moving leading back */
		tp->tdis_lead = tp->tdis_trail;
	}
	return 0;
}

/**
 * @brief
 * 	dis_gss_wcommit - routine to commit/uncommit write data
 *
 * @param[in] fd - file descriptor
 * @param[in] commit_flag - indication for commit or uncommit
 *
 * @return	int
 * @retval	0	success
 */
static int
dis_gss_wcommit(int fd, int commit_flag)
{
	struct gss_disbuf *tp;
	struct gssdis_chan *chan;

	chan = (struct gssdis_chan *) gss_get_chan(fd);
	if (chan == NULL)
		return -1;

	tp = &(chan->writebuf);

	if (commit_flag) {
		/* commit by moving trailing up */
		tp->tdis_trail = tp->tdis_lead;
	} else {
		/* uncommit by moving leading back */
		tp->tdis_lead = tp->tdis_trail;
	}
	return 0;
}

/**
 * @brief
 * 	-tcp_gss_send_token - assemble gss token and writes the token into
 *	writebuf for wflush
 *
 * @param[in] fd - file descriptor
 * @param[in] type - token type - context or wrapped msg
 * @param[in] data - token string data
 * @param[in] len - length of data
 *
 * @return	int
 * @retval	PBS_GSS_OK 	on success
 * @retval	!= PBS_GSS_OK	on error
 *
 */
int
tcp_gss_send_token(int fd, enum TCP_GSS_MSG_TYPES type, char *data, int len)
{
	int retval = DIS_SUCCESS;
	int ntotlen;
	char bufflen[sizeof(int)];

	ntotlen = htonl(len);
	memcpy(bufflen, &ntotlen, sizeof(int));

	retval = transport_puts(fd, (char*)&type, 1) != 1 ?
		    DIS_PROTO : DIS_SUCCESS;

	if (retval == DIS_SUCCESS) {
		retval = transport_puts(fd, bufflen, sizeof(int)) != sizeof(int) ?
			DIS_PROTO : DIS_SUCCESS;
	}

	if (retval == DIS_SUCCESS) {
		retval = transport_puts(fd, data, len) != len ?
			DIS_PROTO : DIS_SUCCESS;
	}

	transport_wcommit(fd, retval == DIS_SUCCESS);

	if (retval != DIS_SUCCESS)
		return PBS_GSS_ERR_SENDTOKEN;

	return PBS_GSS_OK;
}

/**
 * @brief
 * 	-DIS_tcp_gss_wflush - passes the data to bottom layer for real wflush
 *	if gss context has been established the data are encrypted and token is assembled first
 *
 *
 * @param[in] sock - socket descriptor
 *
 * @return	int
 * @retval	0	success
 * @retval	-1	error
 *
 */
int
DIS_tcp_gss_wflush(int fd)
{
	struct gss_disbuf *tp;
	struct gssdis_chan *chan;
	uint32_t ct;
	char *pb;
	char *data_out;
	int len_out;
	int wrap = 0;

	chan = (struct gssdis_chan *)gss_get_chan(fd);
	if (chan == NULL)
		return -1;

	if ((chan->gss_extra != NULL) && (chan->gss_extra->ready))
		wrap = 1;

	tp = &(chan->writebuf);
	if (!tp)
		return DIS_PROTO;

	if (tp->tdis_trail == 0)
		return 0;

	if (wrap) {
		if (pbs_gss_wrap(chan->gss_extra, tp->tdis_thebuf, tp->tdis_trail, &data_out, &len_out) != PBS_GSS_OK)
			return -1;

		ct = len_out;
		pb = data_out;

		if (tcp_gss_send_token(fd, TCP_GSS_WRAP, pb, ct) != PBS_GSS_OK)
			return -1;

		free(data_out);
	} else {
		int retval;

		ct = tp->tdis_trail;
		pb = tp->tdis_thebuf;

		retval = transport_puts(fd, pb, ct) != ct ?
			DIS_PROTO : DIS_SUCCESS;

		transport_wcommit(fd, retval == DIS_SUCCESS);

		if (retval != DIS_SUCCESS)
			return -1;
	}

	tp->tdis_eod = tp->tdis_lead;
	dis_gss_pack_buff(tp);

	return 0;
}

/**
 * @brief
 * 	-__tcp_gss_process - this function handles data before process_request()
 *	if the data are GSS handshake related then handshake is done
 *	if the data are wrapped then unwrapping is done and true is returned
 *	if gss is not used (yet) then true is returned
 *
 *
 * @param[in] sfds - socket descriptor
 * @param[in] hostname - server hostname
 * @param[out] ebuf - error buffer
 * @param[in] ebufsz - size of error buffer
 *
 * @return	int
 * @retval	>0	data ready
 * @retval	0	no data ready
 * @retval	-1	error
 * @retval	-2	on EOF
 *
 */
int
__tcp_gss_process(int sfds, char *hostname, char *ebuf, int ebufsz)
{
	pbs_gss_extra_t *gss_extra = NULL;
	char *data;
	char *data_out = NULL;
	int len_out = 0;
	unsigned int data_len;
	enum TCP_GSS_MSG_TYPES type;
	struct gss_disbuf *tp;
	struct gssdis_chan *chan;
	int ct;
	int i;

	DIS_tcp_setup(sfds);

	if ((gss_extra = (pbs_gss_extra_t *)tcp_get_extra(sfds)) == NULL) {
		gss_extra = pbs_gss_alloc_gss_extra();
		tcp_set_extra(sfds, gss_extra);
	}

	gss_extra->role = PBS_GSS_SERVER;
	gss_extra->req_output_size = DIS_GSS_BUF_SIZE;
	
	if (gss_extra->hostname == NULL) {
		gss_extra->hostname = strdup(hostname);
		if (gss_extra->hostname == NULL) {
			snprintf(ebuf, ebufsz, "malloc failure");
			return -1;
		}
	}

	if (gss_extra->establishing == 0 && gss_extra->ready == 0)
		return 1; /* no gss token (yet) -> cleartext is ready */

	i = transport_getc(sfds);
	if (i <= 0) {
		return ((i == 0) ? -2 : i);
	}

	type = (enum TCP_GSS_MSG_TYPES)i;
	if (type >= TCP_GSS_LAST_MSG) {
		snprintf(ebuf, ebufsz, "unknown message type");
		return -1;
	}

	data = malloc(sizeof(int));
	if (data == NULL) {
		snprintf(ebuf, ebufsz, "malloc failure");
		return -1;
	}
	i = transport_gets(sfds, data, sizeof(int));
	if (i <= 0) {
		return ((i == 0) ? -2 : i);
	}
	if (i < sizeof(int)) {
		snprintf(ebuf, ebufsz, "not enough data to datermine data length");
		return -1;
	}

	data_len = ntohl(*((int *) data));

	data = realloc(data, data_len);
	if (data == NULL) {
		snprintf(ebuf, ebufsz, "realloc failure");
		return -1;
	}
	i = transport_gets(sfds, data, data_len);
	if (i <= 0) {
		return ((i == 0) ? -2 : i);
	}
	if (i < data_len) {
		snprintf(ebuf, ebufsz, "not enough data");
		return -1;
	}

	transport_rcommit(sfds, 1);

	switch (type) {

		case TCP_GSS_CTX:
			if (pbs_gss_establish_context(gss_extra, gss_extra->hostname, data, data_len, &data_out, &len_out) != PBS_GSS_OK) {
				snprintf(ebuf, ebufsz, "Failed to establish GSS context");
				return -1;
			}

			if (len_out > 0) {
				if (tcp_gss_send_token(sfds, TCP_GSS_CTX, data_out, len_out) != PBS_GSS_OK) {
					snprintf(ebuf, ebufsz, "Failed to assemble GSS context token");
					free(data_out);
					free(data);
					return -1;
				}
				if (DIS_tcp_wflush(sfds)) {
					snprintf(ebuf, ebufsz, "Failed to send GSS context token");
					free(data_out);
					free(data);
					return -1;
				}
			}

			free(data_out);
			free(data);

			if (gss_extra->gssctx_established) {
				gss_extra->ready = 1;

				if (DIS_tcp_gss_set(sfds, gss_extra) != PBS_GSS_OK) {
					snprintf(ebuf, ebufsz, "can not set GSS data");
					return -1;
				}
			}

			return 0; /* gss context -> no data for upper layer */

		case TCP_GSS_WRAP:
			chan = (struct gssdis_chan *) gss_get_chan(sfds);
			if (chan == NULL) {
				snprintf(ebuf, ebufsz, "wrapped data ready but no GSS data available");
				return -2;
			}
			dis_gss_clear(&(chan->cleartext));
			tp = &(chan->cleartext);
			if (!tp)
				return -1;

			if (pbs_gss_unwrap(gss_extra, data, data_len, &data_out, &len_out) != PBS_GSS_OK) {
				snprintf(ebuf, ebufsz, "unwrapping GSS token failed");
				free(data_out);
				free(data);
				return -1;
			}

			ct = dis_gss_fillbuffer(tp, data_out, len_out);

			free(data_out);
			free(data);

			if (ct == len_out)
				return ct;
			break;

		default:
			snprintf(ebuf, ebufsz, "incorrect message type");
			free(data);
			return -1;
	}

	return -1;
}

/**
 * @brief
 * 	-DIS_gss_funcs - setup supports routines for dis, "data is strings", to
 * 	use gss stream I/O.
 *
 * @param[in] fd - socket descriptor
 * 
 * @return	void
 *
 */
void
DIS_gss_funcs()
{
	if (dis_getc != dis_gss_getc) {
		dis_getc = dis_gss_getc;
		dis_puts = dis_gss_puts;
		dis_gets = dis_gss_gets;
		disr_skip = dis_gss_rskip;
		disr_commit = dis_gss_rcommit;
		disw_commit = dis_gss_wcommit;
	}
}

/**
 * @brief
 * 	-DIS_tcp_gss_set - Associate GSSAPI information with a stream
 *	and resize gssrdbuf to appropriate size.
 *
 * @param[in] fd - socket descriptor
 * @param[in] extra - gss structure for association
 *
 * @return	int
 * @retval	PBS_GSS_OK on success
 * @retval	!= PBS_GSS_OK on error
 */
int
DIS_tcp_gss_set(int fd, pbs_gss_extra_t *gss_extra)
{
	struct gssdis_chan *chan;
	chan = (struct gssdis_chan *) gss_get_chan(fd);
	if (chan == NULL)
		return -1;

	chan->gss_extra = gss_extra;

	if (!chan->gss_extra->gssctx_established)
		return PBS_GSS_OK;

	struct gss_disbuf *tp = &chan->gss_readbuf;
	if (tp->tdis_bufsize < gss_extra->max_input_size)
		if (dis_gss_buff_resize(tp, gss_extra->max_input_size))
			return PBS_GSS_ERR_WRAPSIZE;

	return PBS_GSS_OK;
}

/**
 * @brief
 * 	-tcp_gss_send_auth - encodes and sends auth batch request,
 *	which initiates the gss handshake on server
 *
 * @param[in] sock - socket descriptor
 *
 * @return	int
 * @retval	PBS_GSS_OK on success
 * @retval	!= PBS_GSS_OK on error
 */
int
tcp_gss_send_auth(int sock)
{
	struct batch_reply *reply;
	int rc;

	DIS_tcp_setup(sock);

	if (encode_DIS_ReqHdr(sock, PBS_BATCH_AuthExternal, pbs_current_user) ||
		diswuc(sock, AUTH_GSS) || /* authentication_type */
		diswsi(sock, 0) || /* credentials length not used */
		encode_DIS_ReqExtend(sock, NULL)) {

		pbs_errno = PBSE_SYSTEM;
		return PBS_GSS_ERR_INTERNAL;
	}

	if (DIS_tcp_wflush(sock)) {
		pbs_errno = PBSE_SYSTEM;
		return PBS_GSS_ERR_INTERNAL;
	}

	reply = PBSD_rdrpy_sock(sock, &rc);

	if (reply == NULL) {
		pbs_errno = PBSE_BADCRED;
		return PBS_GSS_ERR_INTERNAL;
	}

	if ((reply->brp_code != 0)) {
		pbs_errno = PBSE_BADCRED;
		PBSD_FreeReply(reply);
		return PBS_GSS_ERR_INTERNAL;
	}

	PBSD_FreeReply(reply);

	return PBS_GSS_OK;
}

/**
 * @brief
 * 	-tcp_gss_client_authenticate - sends the auth batch request and
 *	initiates and performs the gss handshake on client
 *
 * @param[in] sock - socket descriptor
 * @param[in] hostname - server hostname
 * @param[out] ebuf - error buffer
 * @param[in] ebufsz - size of error buffer
 *
 * @return	int
 * @retval	PBS_GSS_OK on success
 * @retval	!= PBS_GSS_OK on error
 */
int
tcp_gss_client_authenticate(int sock, char *hostname, char *ebuf, int ebufsz)
{
	pbs_gss_extra_t *gss_extra = NULL;
	char *data_in = NULL;
	int len_in = 0;
	char *data_out = NULL;
	int len_out = 0;
	enum TCP_GSS_MSG_TYPES type;
	int i;
	unsigned int data_len;
	char *data;

	if ((gss_extra = (pbs_gss_extra_t *)tcp_get_extra(sock)) == NULL) {
		gss_extra = pbs_gss_alloc_gss_extra();
		if (gss_extra == NULL) {
			snprintf(ebuf, ebufsz, "gss_extra allocation failed");
			pbs_errno = PBSE_SYSTEM;

			return PBS_GSS_ERR_INTERNAL;
		}
		tcp_set_extra(sock, gss_extra);
	}

	gss_extra->role = PBS_GSS_CLIENT;
	gss_extra->req_output_size = DIS_GSS_BUF_SIZE;

	if (gss_extra->hostname == NULL) {
		gss_extra->hostname = strdup(hostname);
		if (gss_extra->hostname == NULL) {
			snprintf(ebuf, ebufsz, "malloc failure");
			pbs_errno = PBSE_SYSTEM;

			return PBS_GSS_ERR_INTERNAL;
		}
	}

	if (tcp_gss_send_auth(sock) != PBS_GSS_OK) {
		snprintf(ebuf, ebufsz, "authentication failed");

		return PBS_GSS_ERR_INTERNAL;
	}

	pbs_gss_set_log_handlers(tcp_gss_display_status, tcp_gss_display, NULL);

	do {
		if (pbs_gss_establish_context(gss_extra, gss_extra->hostname, data_in, len_in, &data_out, &len_out) != PBS_GSS_OK) {
			snprintf(ebuf, ebufsz, "Failed to establish GSS context");
			pbs_errno = PBSE_SYSTEM;

			return PBS_GSS_ERR_CONTEXT_ESTABLISH;
		}

		if (len_in) {
			free(data_in);
			len_in = 0;
		}

		if (len_out) {
			if (tcp_gss_send_token(sock, TCP_GSS_CTX, data_out, len_out) != PBS_GSS_OK) {
				snprintf(ebuf, ebufsz, "Failed to assemble GSS context token");
				pbs_errno = PBSE_SYSTEM;
				free(data_out);

				return PBS_GSS_ERR_SENDTOKEN;
			}

			if (DIS_tcp_wflush(sock)) {
				snprintf(ebuf, ebufsz, "Failed to send GSS context token");
				pbs_errno = PBSE_SYSTEM;
				free(data_out);

				return PBS_GSS_ERR_INTERNAL;
			}

			free(data_out);
			data_out = NULL;
			len_out = 0;
		}

		if (gss_extra->gssctx_established == 0) {
			/* recieve ctx token */

			i = transport_getc(sock);
			if (i <= 0) {
				pbs_errno = PBSE_SYSTEM;

				return PBS_GSS_ERR_RECVTOKEN;
			}
			type = (unsigned char)i;
			if (type != TCP_GSS_CTX) {
				snprintf(ebuf, ebufsz, "incorrect GSS token type");
				pbs_errno = PBSE_SYSTEM;

				return PBS_GSS_ERR_RECVTOKEN;
			}

			data = malloc(sizeof(int));
			if (data == NULL) {
				snprintf(ebuf, ebufsz, "malloc failure");
				pbs_errno = PBSE_SYSTEM;

				return PBS_GSS_ERR_INTERNAL;
			}

		    	i = transport_gets(sock, data, sizeof(int));
			if (i <= 0) {
				pbs_errno = PBSE_SYSTEM;

				return PBS_GSS_ERR_RECVTOKEN;
			}
			if (i < sizeof(int)) {
				snprintf(ebuf, ebufsz, "not enough data to datermine data length");
				pbs_errno = PBSE_SYSTEM;

				return PBS_GSS_ERR_RECVTOKEN;
			}

			data_len = ntohl(*((int *) data));

			free(data);

			data = malloc(data_len);
			if (data == NULL) {
				snprintf(ebuf, ebufsz, "malloc failure");
				pbs_errno = PBSE_SYSTEM;

				return PBS_GSS_ERR_INTERNAL;
			}
			i = transport_gets(sock, data, data_len);
			if (i <= 0) {
				pbs_errno = PBSE_SYSTEM;

				return PBS_GSS_ERR_RECVTOKEN;
			}
			if (i < data_len) {
				snprintf(ebuf, ebufsz, "not enough data");
				pbs_errno = PBSE_SYSTEM;

				return PBS_GSS_ERR_RECVTOKEN;
			}

			transport_rcommit(sock, 1);

			len_in = data_len;
			data_in = malloc(len_in);
			if (data_in == NULL) {
				snprintf(ebuf, ebufsz, "malloc failure");
				pbs_errno = PBSE_SYSTEM;

				return PBS_GSS_ERR_INTERNAL;
			}

			memcpy(data_in, data, len_in);

			free(data);
		}

		if (gss_extra->gssctx_established) {
			gss_extra->ready = 1;
		}

	} while (gss_extra->ready == 0);

	if (DIS_tcp_gss_set(sock, gss_extra) != PBS_GSS_OK) {
		snprintf(ebuf, ebufsz, "can not set GSS data");
		pbs_errno = PBSE_SYSTEM;

		return PBS_GSS_ERR_CONTEXT_SAVE;
	}

	return PBS_GSS_OK;
}
#endif
